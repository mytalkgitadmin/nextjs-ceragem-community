# Ceragem Community (FETA) 비즈니스 로직 분석 문서

## 📋 프로젝트 개요

**Ceragem Community Test (FETA)**는 Next.js 15와 React 19 기반으로 구축된 실시간 커뮤니티 플랫폼입니다.

### 핵심 기술 스택

- **Frontend**: Next.js 15 (App Router) + React 19 + TypeScript
- **State Management**: Zustand + TanStack Query
- **Real-time Chat**: Sendbird SDK
- **Authentication**: Firebase Auth
- **UI Framework**: Tailwind CSS + Radix UI
- **Architecture**: Feature Sliced Design (FSD)

---

## 🏗️ 아키텍처 구조 (Feature Sliced Design)

FSD는 프런트엔드 애플리케이션을 계층별로 구조화하는 아키텍처 패턴입니다.

### 레이어 구조 (상위 → 하위)

```
src/
├── app/                    # 앱 초기화 및 전역 설정
├── views/                  # 페이지별 뷰 컴포넌트 (FSD pages 레이어)
├── widgets/                # 독립적인 대형 UI 블록
├── features/               # 비즈니스 기능별 모듈
├── entities/               # 도메인 엔티티 모델
└── shared/                 # 공통 유틸리티 및 라이브러리
```

### 세그먼트 구조

각 레이어는 다음과 같은 세그먼트로 구성됩니다:

- `api/`: 백엔드 통신 및 데이터 로직
- `model/`: 도메인 모델, 스키마, 비즈니스 로직
- `ui/`: UI 컴포넌트 및 스타일
- `lib/`: 해당 슬라이스의 공통 라이브러리
- `config/`: 환경 설정 및 기능 플래그

---

## 🎯 주요 비즈니스 기능 분석

### 1. 인증 시스템 (Authentication)

**위치**: `src/features/auth/`

#### 핵심 로직

- **토큰 기반 인증**: Access Token, Refresh Token, Session Token 관리
- **자동 토큰 갱신**: 토큰 만료 시 자동으로 갱신 처리
- **영속적 상태 관리**: localStorage를 통한 로그인 상태 유지

#### 주요 파일

- `authStore.ts`: Zustand 기반 인증 상태 관리
- `api/`: 로그인, 로그아웃, 토큰 갱신 API
- `hooks/useAuth.ts`: 인증 상태 훅

#### 비즈니스 로직

```typescript
// 1. 로그인 시 토큰 저장 및 사용자 정보 업데이트
login: (authData) => {
  set({
    isAuthenticated: true,
    accessToken: authData.accessToken,
    refreshToken: authData.refreshToken,
    sessionToken: authData.sessionToken,
    userId: authData.sendBirdId,
    userProfile: authData.accountProfile,
  });
};

// 2. 토큰 갱신 시 중복 요청 방지
setTokenRefreshPromise: (promise) => {
  set({ tokenRefreshPromise: promise });
};
```

### 2. 친구 관리 시스템 (Friend Management)

**위치**: `src/features/friend/`

#### 핵심 로직

- **친구 상태 관리**: NORMAL, REQUEST, REQUESTED, BLOCK, HIDE, FAVORITE 등
- **그룹 기반 친구 관리**: 친구를 그룹별로 분류 및 관리
- **실시간 상태 동기화**: TanStack Query를 통한 캐시 무효화

#### 주요 파일

- `api.ts`: 친구 관련 모든 API 요청 함수
- `api/dto-types.ts`: API 응답 데이터 타입
- `api/contracts-types.ts`: 도메인 모델 타입
- `api/dto-mappers.ts`: DTO ↔ Domain 변환 함수

#### 비즈니스 로직

```typescript
// 친구 목록 조회 (상태별 필터링)
export const useFriends = (params: FriendListParams) => {
  return useQuery({
    queryKey: ["user", "friends", params],
    queryFn: async () => getFriendListApi(params),
    enabled: params.friendType.length > 0,
  });
};

// 친구 즐겨찾기 토글
export const useFriendFavorite = () => {
  return useMutation({
    mutationFn: async (data: { friendId: number; isFavorite: boolean }) => {
      const dtoResponse = await apiRequest(
        FRIEND_ENDPOINTS.PUT_FRIEND_FAVORITE,
        data
      );
      return mapFriendListResponse(dtoResponse);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["user"] });
    },
  });
};
```

### 3. 실시간 채팅 시스템 (Chat)

**위치**: `src/features/chat/`

#### 핵심 로직

- **Sendbird 기반 실시간 채팅**: 메시지 송수신, 채널 관리
- **파일 업로드 및 검색**: 이미지, 동영상 등 미디어 파일 관리
- **채널 타입 관리**: GROUP, DIRECT, FAMILY, MY, ADMIN 타입별 처리

#### 주요 파일

- `api/createChannel.ts`: 채팅 채널 생성
- `api/fileSearchApi.ts`: 파일 검색 API
- `api/fileUploadApi.ts`: 파일 업로드 API
- `store.ts`: 현재 채널 상태 관리
- `hooks/`: 채팅 관련 커스텀 훅들

#### 비즈니스 로직

```typescript
// 채널 생성 API
export const createChannel = async (
  params: CreateChannelRequest
): Promise<CreateChannelData> => {
  const dtoRequest: CreateChannelRequestDTO = {
    accountIds: params.accountIds,
    channelName: params.channelName,
    channelType: params.channelType,
  };

  const dtoResponse = await apiRequest<CreateChannelResponseDTO>(
    CHAT_ENDPOINTS.CREATE_CHANNEL,
    dtoRequest
  );

  return mapCreateChannelResponse(dtoResponse);
};

// 파일 업로드 API
export const uploadFile = async (
  params: FileUploadRequest
): Promise<FileUploadData> => {
  const formData = new FormData();
  formData.append("file", params.file);
  if (params.subCategory) formData.append("subCategory", params.subCategory);

  // 파일 전용 axios 인스턴스 사용
  const dtoResponse = await fileUploadInstance.post("/file/upload", formData);
  return mapFileUploadResponse(dtoResponse.data);
};
```

### 4. 알림 시스템 (Notifications)

**위치**: `src/features/notifications/`

#### 핵심 로직

- **카테고리별 알림 관리**: FRIEND_REQUEST, CHAT, SYSTEM 등
- **읽음/삭제 상태 관리**: 알림 상태 변경 및 카운트 관리
- **실시간 알림 업데이트**: Zustand 스토어를 통한 상태 관리

#### 주요 파일

- `api.ts`: 알림 조회, 읽음 처리, 삭제 API
- `model.ts`: 알림 데이터 모델
- `store/useTotalNotificationStore.ts`: 알림 카운트 관리

#### 비즈니스 로직

```typescript
// 알림 읽음 처리
export const useMarkNotiAsRead = () => {
  return useMutation({
    mutationFn: ({ notificationId }: { notificationId: string }) =>
      patchNotiApi(notificationId),
    onSuccess: (_, { category }) => {
      queryClient.invalidateQueries({ queryKey: ["notiList"] });

      // 친구 요청 알림인 경우 카운트 감소
      if (category === "FRIEND_REQUEST") {
        const { decreaseFriendRequestCount } =
          useTotalNotificationStore.getState();
        decreaseFriendRequestCount();
      }
    },
  });
};
```

### 5. 프로필 관리 시스템 (Profile)

**위치**: `src/features/profile/`

#### 핵심 로직

- **사용자 프로필 조회 및 수정**: 개인정보, 프로필 이미지 관리
- **Sendbird 프로필 연동**: 채팅용 프로필 정보 동기화
- **파일 업로드**: 프로필 이미지 업로드 및 썸네일 생성

#### 주요 파일

- `api.ts`: 프로필 조회, 수정, 파일 업로드 API
- `hooks/`: 프로필 관련 커스텀 훅들
- `ui/`: 프로필 UI 컴포넌트들

---

## 🔧 공통 인프라 레이어 (Shared)

### API 관리 (`src/shared/api/`)

#### 핵심 구조

- **axios.ts**: HTTP 클라이언트 설정 및 인터셉터
- **request.ts**: RESTful API 요청 함수들
- **endpoints.ts**: API 엔드포인트 정의
- **model.ts**: 공통 API 타입 정의

#### 주요 기능

```typescript
// BFF(Backend For Frontend) 패턴으로 API 프록시
export const apiRequest = <T = unknown>(
  endpoint: Endpoint,
  data?: unknown,
  params?: RequestParams,
  pathParams?: Record<string, string | number>
): Promise<T> => {
  const withPrefix = (url: string) => `/api/familytown${url}`;
  // ... 메서드별 라우팅 로직
};
```

### 공통 훅스 (`src/shared/hooks/`)

- `useAsyncState.ts`: 비동기 상태 관리
- `useFileUpload.ts`: 파일 업로드 유틸리티
- `useMediaQuery.ts`: 반응형 디자인 지원
- `useMobileDevice.ts`: 모바일 디바이스 감지

---

## 🧩 엔티티 레이어 (Entities)

### 주요 도메인 모델

#### 1. Chat Entity (`src/entities/chat/`)

- 채팅 메시지, 채널 정보 등 채팅 관련 기본 타입

#### 2. Friend Entity (`src/entities/friend/`)

- 친구 관계, 그룹 정보 등 친구 관련 기본 타입

#### 3. Profile Entity (`src/entities/profile/`)

- 사용자 프로필, 개인정보 등 프로필 관련 기본 타입

---

## 🎨 위젯 레이어 (Widgets)

### 주요 위젯들

#### 1. 레이아웃 (`src/widgets/layouts/`)

- `ProtectedLayout`: 인증이 필요한 페이지 레이아웃
- `DefaultLayout`: 기본 페이지 레이아웃

#### 2. 프로필 (`src/widgets/Profile/`)

- `ProfileViewer`: 프로필 상세 보기
- `ProfileCard`: 프로필 카드 컴포넌트
- `ProfileAvatar`: 프로필 아바타 (개인/그룹)

#### 3. 친구 개요 (`src/widgets/FriendsOverview/`)

- `FriendsOverview`: 친구 목록 메인 화면
- `FriendsList`: 친구 목록 컴포넌트

#### 4. 알림 (`src/widgets/Notifications/`)

- `NotificationList`: 알림 목록
- `NotificationCard`: 개별 알림 카드

---

## 🔄 데이터 플로우

### 1. API 요청 플로우

```
Component → Feature Hook → API Function → Shared Request → Backend
                ↓
Component ← DTO Mapper ← API Response ← Shared Request ← Backend
```

### 2. 상태 관리 플로우

```
User Action → Component → Feature Hook → Zustand Store → Component Re-render
                                    ↓
                                TanStack Query Cache → Component Re-render
```

### 3. 인증 플로우

```
Login → Auth API → Token Storage → Middleware Check → Protected Route Access
```

---

## 🔒 보안 및 인증

### 미들웨어 (`middleware.ts`)

- **토큰 검증**: 헤더와 쿠키의 토큰 일치성 확인
- **자동 리다이렉트**: 인증 실패 시 로그인 페이지로 이동
- **JWT 토큰 관리**: Access/Refresh 토큰 자동 갱신

### 토큰 관리 전략

1. **다중 토큰 시스템**: Access, Refresh, Session 토큰
2. **자동 갱신**: 토큰 만료 전 자동 갱신 로직
3. **중복 방지**: 동시 갱신 요청 방지를 위한 Promise 캐싱

---

## 📊 상태 관리 패턴

### 1. Zustand (전역 상태)

- 인증 상태 (`authStore.ts`)
- 채널 상태 (`chat/store.ts`)
- 알림 카운트 (`notifications/store/`)

### 2. TanStack Query (서버 상태)

- API 데이터 캐싱 및 동기화
- 백그라운드 자동 재요청
- 낙관적 업데이트

---

## 🔍 개발 도구 및 컨벤션

### 아키텍처 린팅

```bash
npm run lint:arch        # Steiger를 통한 FSD 규칙 검증
```

### 코드 생성

```bash
npm run gen:fsd          # FSD 구조에 맞는 슬라이스 자동 생성
```

### 프로젝트 컨벤션

- **타입 안전성**: TypeScript를 통한 강력한 타입 체크
- **DTO 패턴**: API 응답과 도메인 모델 분리
- **모듈 경계**: 각 레이어 간 의존성 규칙 준수

---

## 📈 성능 최적화

### 1. 코드 분할

- Next.js App Router의 자동 코드 분할
- 컴포넌트별 lazy loading

### 2. 캐싱 전략

- TanStack Query의 지능적 캐싱
- 이미지 및 정적 자산 캐싱

### 3. 번들 최적화

- Turbopack을 통한 빠른 개발 빌드
- Tree shaking을 통한 불필요한 코드 제거

---

이 문서는 Ceragem Community (FETA) 프로젝트의 전반적인 비즈니스 로직과 아키텍처를 분석한 결과입니다. 각 레이어와 기능별로 명확한 역할 분담과 데이터 플로우를 통해 유지보수 가능하고 확장 가능한 구조를 가지고 있습니다.
